var M=Object.defineProperty;var N=(i,o,a)=>o in i?M(i,o,{enumerable:!0,configurable:!0,writable:!0,value:a}):i[o]=a;var g=(i,o,a)=>(N(i,typeof o!="symbol"?o+"":o,a),a);import{F as B}from"./common_glsl-BoMhYY0K.js";import{C as G}from"./tuples-6lOvLNBg.js";import{d as b,p as A,q as L,w as T,f as $,c as C,B as D,i as P,z as q,e as s,_ as O,r as v,h as u,g as p,a as d,b as c,F as X}from"./index-BgDKrswi.js";class _{constructor(o,a,e){g(this,"r");g(this,"g");g(this,"b");this.r=o,this.g=a,this.b=e}to_vec3(){return[this.r,this.g,this.b]}to_hex(){const a=this.to_vec3().map(t=>Math.floor(t*255)),[e,r,n]=a.map(t=>t.toString(16).padStart(2,"0"));return`#${e}${r}${n}`}static from_vec3(o){if(o.length!==3)throw new Error("rgb_f32 length must be 3");const[a,e,r]=o;return new _(a,e,r)}static from_hex(o){const e=[0,1,2].map(l=>o.substring(1+2*l,1+2*(l+1))).map(l=>parseInt(l,16)),[r,n,t]=e.map(l=>l/255);return new _(r,n,t)}}const Y=4,Z=3,U=new G(Y,Z);class Se{serialize(o){return{terms:o.terms.map(e=>{const{frequencies:r,coefficient:n}=e,{n:t,m:l}=r,{r:h,theta:x}=n;return U.serialize([t,l,h,x])})}}validate(o){if(!Array.isArray(o.terms))return console.error("terms must be an array"),!1;for(const a of o.terms)if(!U.validate(a))return!1;return!0}deserialize(o){const a=o.terms.map(e=>{const[r,n,t,l]=U.deserialize(e);return[r,n,t,l]});return B.from_tuples(a)}}function Ue(){return{input_axes:{xyrt_flags:[!1,!1,!1,!1],color:new _(1,1,1),thickness:.01},output_axes:{xyrt_flags:[!1,!1,!1,!1],color:new _(0,1,1),thickness:.1},pulse:{xyrt_flags:[!1,!1,!1,!1],color:new _(1,1,0),thickness:.1},grid:{xyrt_flags:[!1,!1,!1,!1],color:new _(1,1,1),thickness:.1}}}const V=b({__name:"ColorPicker",props:A({modelValue:{}},{color_hex:{default:"#000000"},color_hexModifiers:{}}),emits:A(["update:modelValue"],["update:color_hex"]),setup(i,{emit:o}){const a=i,e=L(i,"color_hex");e.value=a.modelValue.to_hex();const r=o;return T(e,n=>{r("update:modelValue",_.from_hex(n))}),(n,t)=>($(),C("label",null,[D(n.$slots,"default",{class:"center-vertically"}),P(s("input",{type:"color","onUpdate:modelValue":t[0]||(t[0]=l=>e.value=l)},null,512),[[q,e.value]])]))}}),j=["min","max","step","value"],J=b({__name:"RangeSlider",props:{modelValue:{},min:{},max:{},step:{}},emits:["update:modelValue"],setup(i,{emit:o}){const a=o;function e(r){const n=r.target,t=parseFloat(n.value);a("update:modelValue",t)}return(r,n)=>($(),C("label",null,[D(r.$slots,"default",{},void 0,!0),s("input",{id:"slider",type:"range",min:r.$props.min,max:r.$props.max,step:r.$props.step,value:r.$props.modelValue,onInput:e},null,40,j)]))}}),y=O(J,[["__scopeId","data-v-44446a6f"]]);function w(i){return o=>{const a=o.target;i.value=a.checked}}const K=["checked"],Q=["checked"],W=["checked"],ee=["checked"],k=b({__name:"XYRTFlags",props:{modelValue:{default:()=>[!1,!1,!1,!1]}},emits:["update:modelValue"],setup(i,{emit:o}){const a=i,[e,r,n,t]=a.modelValue,l=v(e),h=v(r),x=v(n),S=v(t),H=o;T([l,h,x,S],R=>{H("update:modelValue",R)});const z=w(l),E=w(h),F=w(x),I=w(S);return(R,m)=>($(),C("div",null,[u(" Enabled: "),s("label",null,[s("input",{type:"checkbox",checked:l.value,onChange:m[0]||(m[0]=(...f)=>p(z)&&p(z)(...f))},null,40,K),u("x")]),s("label",null,[s("input",{type:"checkbox",checked:h.value,onChange:m[1]||(m[1]=(...f)=>p(E)&&p(E)(...f))},null,40,Q),u("y")]),s("label",null,[s("input",{type:"checkbox",checked:x.value,onChange:m[2]||(m[2]=(...f)=>p(F)&&p(F)(...f))},null,40,W),u("r")]),s("label",null,[s("input",{type:"checkbox",checked:S.value,onChange:m[3]||(m[3]=(...f)=>p(I)&&p(I)(...f))},null,40,ee),u("theta")])]))}}),te=s("p",null," These options help visualize key points in the complex plane. This is aimed at the mathematically curious, but I find it also adds some artistic flair to the image! ",-1),le=s("p",null,"Note: reference geometry is not included when exporting patterns.",-1),se=s("h3",null,"Axes",-1),oe={class:"form-row"},ae={class:"form-row"},re={class:"form-row"},ne=s("div",{class:"form-row"},[s("details",null,[s("summary",null,"Help"),u(" Overlay a set of axes to show where you are in the complex plane ")])],-1),ue=s("h3",null,"Palette Axes",-1),ie={class:"form-row"},de={class:"form-row"},me={class:"form-row"},pe=s("details",{class:"form-row"},[s("summary",null,"Help"),u(" include axes in the color palette. Since these patterns significantly distort the complex plane, this helps you see how the axes warp. ")],-1),ce=s("h3",null,"Pulses",-1),_e={class:"form-row"},fe={class:"form-row"},he={class:"form-row"},xe=s("div",{class:"form-row"},[s("details",null,[s("summary",null,"Help"),u(" Create animated pulses in one of the coordinate directions to help visualize how the coordinate directions warp. ")])],-1),ve=s("h3",null,"Grid Lines",-1),ge={class:"form-row"},Ve={class:"form-row"},ye={class:"form-row"},we=s("div",{class:"form-row"},[s("details",null,[s("summary",null,"Help"),u(" Draw parallel grid lines in the palette to show how the coordinate grid warps. ")])],-1),Te=b({__name:"ReferenceGeometryEditor",props:{modelValue:{}},emits:["update:modelValue"],setup(i,{emit:o}){const e=v(i.modelValue),r=o;return T(e,n=>{r("update:modelValue",n)},{deep:!0}),(n,t)=>($(),C(X,null,[te,le,se,s("div",oe,[d(k,{id:"input-axes-xyrt",modelValue:e.value.input_axes.xyrt_flags,"onUpdate:modelValue":t[0]||(t[0]=l=>e.value.input_axes.xyrt_flags=l)},null,8,["modelValue"])]),s("div",ae,[d(V,{id:"input-axes-color",modelValue:e.value.input_axes.color,"onUpdate:modelValue":t[1]||(t[1]=l=>e.value.input_axes.color=l)},{default:c(()=>[u("Color: ")]),_:1},8,["modelValue"])]),s("div",re,[d(y,{id:"input-axes-thickness",min:.001,max:.1,step:.001,modelValue:e.value.input_axes.thickness,"onUpdate:modelValue":t[2]||(t[2]=l=>e.value.input_axes.thickness=l)},{default:c(()=>[u("Thickness: ")]),_:1},8,["modelValue"])]),ne,ue,s("div",ie,[d(k,{id:"output-axes-xyrt",modelValue:e.value.output_axes.xyrt_flags,"onUpdate:modelValue":t[3]||(t[3]=l=>e.value.output_axes.xyrt_flags=l)},null,8,["modelValue"])]),s("div",de,[d(V,{id:"output-axes-color",modelValue:e.value.output_axes.color,"onUpdate:modelValue":t[4]||(t[4]=l=>e.value.output_axes.color=l)},{default:c(()=>[u("Color: ")]),_:1},8,["modelValue"])]),s("div",me,[d(y,{id:"output-axes-thickness",min:.001,max:.5,step:.001,modelValue:e.value.output_axes.thickness,"onUpdate:modelValue":t[5]||(t[5]=l=>e.value.output_axes.thickness=l)},{default:c(()=>[u("Thickness: ")]),_:1},8,["modelValue"])]),pe,ce,s("div",_e,[d(k,{id:"pulse-xyrt",modelValue:e.value.pulse.xyrt_flags,"onUpdate:modelValue":t[6]||(t[6]=l=>e.value.pulse.xyrt_flags=l)},null,8,["modelValue"])]),s("div",fe,[d(V,{id:"pulse-color",modelValue:e.value.pulse.color,"onUpdate:modelValue":t[7]||(t[7]=l=>e.value.pulse.color=l)},{default:c(()=>[u("Color: ")]),_:1},8,["modelValue"])]),s("div",he,[d(y,{id:"pulse-thickness",min:.001,max:.5,step:.001,modelValue:e.value.pulse.thickness,"onUpdate:modelValue":t[8]||(t[8]=l=>e.value.pulse.thickness=l)},{default:c(()=>[u("Thickness: ")]),_:1},8,["modelValue"])]),xe,ve,s("div",ge,[d(k,{id:"grid-xyrt",modelValue:e.value.grid.xyrt_flags,"onUpdate:modelValue":t[9]||(t[9]=l=>e.value.grid.xyrt_flags=l)},null,8,["modelValue"])]),s("div",Ve,[d(V,{id:"grid-color",modelValue:e.value.grid.color,"onUpdate:modelValue":t[10]||(t[10]=l=>e.value.grid.color=l)},{default:c(()=>[u("Color")]),_:1},8,["modelValue"])]),s("div",ye,[d(y,{id:"grid-thickness",min:.001,max:.5,step:.001,modelValue:e.value.grid.thickness,"onUpdate:modelValue":t[11]||(t[11]=l=>e.value.grid.thickness=l)},{default:c(()=>[u("Thickness:")]),_:1},8,["modelValue"])]),we],64))}});export{_ as C,Se as F,y as R,Te as _,V as a,Ue as d,w as t};
